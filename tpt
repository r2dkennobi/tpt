#!/bin/bash

if [[ -n ${ZSH_VERSION-} ]]; then
  autoload -U +X bashcompinit && bashcompinit
fi

TPT_CACHE_FILE="$HOME/.cache/tpt.runcache"

_print_help() {
  cat <<EOF
  SYNOPSYS:
    tpt [OPTION] [ARGS]...

  DESCRIPTION:
    Transport yourself to another dimension (package folder)

  OPTION:
    --help, -h
      Show this usage screen
    --update-cache, -h
      Update the auto-completion cache
EOF
}

_generate_cache_if_necessary() {
  if ! [[ -e "$TPT_CACHE_FILE" ]]; then
    _generate_cache "$1"
  fi
}

_generate_cache() {
  mkdir -p "$HOME/.cache"
  {
  IFS=' ' read -r -a projects <<< "$1"
  while IFS= read -r p
  do
    dir_path=$(dirname "$p")
    pkg_name=$(basename "$dir_path")
    if [[ ${dir_path} != *"/."* ]]; then
      echo "$pkg_name:$dir_path"
    fi
  done < <(find "${projects[@]}" -type f \( -name ".mjornir.yaml" -o \
                                            -name "package.xml" -o \
                                            -name ".travis.yml" -o \
                                            -name ".gitlab-ci.yml" -o \
                                            -name "WORKSPACE" \))
  } > "$TPT_CACHE_FILE"
}

_bash_complete_packages() {
  (
  while IFS='' read -r line; do
    echo "${line%%:*}"
  done < "$TPT_CACHE_FILE"
  )
}

_tpt() {
  PROJECT_DIR=${PROJECT_DIR:-"$HOME"}
  _generate_cache_if_necessary "$PROJECT_DIR"
  local cur prev verbs

  COMPREPLY=()
  cur=${COMP_WORDS[COMP_CWORD]}
  prev=${COMP_WORDS[COMP_CWORD-1]}
  verbs="-h --help -u --update-cache"

  if [[ ${COMP_CWORD} -eq 1 ]]; then
    COMPREPLY=($(compgen -W "${verbs} $(_bash_complete_packages)" -- "${cur}"))
  else
    case "${prev}" in
      *)
        COMPREPLY=($(compgen -W "$(_bash_complete_packages)" -- "${cur}"))
    esac
  fi

  return 0
}

tpt() {
  PROJECT_DIR=${PROJECT_DIR:-"$HOME"}
  local show_help tpt_back update_cache
  for arg in "$@";
  do
    case $arg in
      -h|--help)
        show_help=true
        shift
        ;;
      -u|--update-cache)
        update_cache=true
        shift
        ;;
      -)
        tpt_back=true
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ ${show_help:-false} == "true" ]]; then
    _print_help
  elif [[ "${tpt_back:-false}" == "true" ]]; then
    cd - || exit
  elif [[ "${update_cache:-false}" == "true" ]]; then
    _generate_cache "$PROJECT_DIR"
  else
    _generate_cache_if_necessary "$PROJECT_DIR"
    local matches=()
    while IFS='' read -r line; do
      package="${line%%:*}"
      path="${line##*:}"
      if [[ "$package" == "$1" ]]; then
        matches+=($path)
      fi
    done < "$TPT_CACHE_FILE"
    if [[ "${#matches[@]}" -eq 0 ]]; then
      return
    elif [[ "${#matches[@]}" -eq 1 ]]; then
      cd "${matches[0]}" || exit
    else
      select path in "${matches[@]}"; do
        cd "$path" || exit
        break
      done
    fi
  fi
}

complete -o bashdefault -F _tpt tpt

# Don't run the command if sourcing the file
if ! [[ $_ != "$0" ]]; then
  tpt "$@"
fi
